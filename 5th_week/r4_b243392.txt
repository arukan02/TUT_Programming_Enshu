プログラミング応用演習I 第2回課題レポート 
氏名: Alcander Imawan
学籍番号: b243392
提出年月日: 2024年5月15日

3.1．キュー
3.1.1. プログラム
--- prog_3_1.c
/* header files */
#include <stdio.h>
#include <stdlib.h>

/* define */
#define ARRAY_MAX 5
#define STR_MAX 256

/* structure */
typedef struct queue {
  int array[ARRAY_MAX];
  int front;
  int end;
} Queue;

/* declearation functions */
void enqueue(Queue *x);
void dequeue(Queue *x);
void print_queue(Queue *x);
int find_next(int current); /* For Assignment 3.1 */

/* for debug */
void print_detailed_queue(Queue *x);

/* main */
int main(void) {
  /* Variables */
  Queue x;
  int num;
  char str[STR_MAX];

  /* Initial settings */
  x.front = 0;
  x.end = 0;

  /* Main loop */
  while(1) { /* Infinite loop */
    puts("Enter the operation number.");
    printf("1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: ");
    fgets(str, sizeof(str), stdin);
    num = atoi(str);
    // selected operation for Queue x
    switch(num) {
    case 1: enqueue(&x);
      break;
    case 2: dequeue(&x);
      break;
    case 3: print_queue(&x);
      break;
    case 4: exit(0);
    case 9: print_detailed_queue(&x); /* not explained */
      break;
    default: printf("-- You input wrong key [%d] --", num);
    }
  }
  return 1;
}

/* enqueue */
void enqueue(Queue *x) {
  char str[STR_MAX];
  if (find_next(x->end) == x->front) {
    puts("-- No resource remained. --");
  } else {
    printf("Input a number to enqueue: ");
    fgets(str, sizeof(str), stdin);
    x->array[x->end] = atoi(str);
    x->end = find_next(x->end);
  }
}

/* dequeue */
void dequeue(Queue *x) {
  if (x->front == x->end) {
    puts("-- There is no data. --");
  } else {
    printf("Dequeue: %d\n", x->array[x->front]);
    x->front = find_next(x->front);
  }
}

/* print all data */
void print_queue(Queue *x) {
  int i;
  if (x->front == x->end) {
    puts("-- There is no data. --");
  } else {
    while (1){
        if(x->front == x->end) {
            break;
        }
        else {
            printf("%d ",x->array[x->front]);
            x->front = find_next(x->front);
        }
    }
    putchar('\n');
  }
}

int find_next(int current){
        return (current + 1) % ARRAY_MAX;
}

/* print all data (detailed) */
void print_detailed_queue(Queue *x) {
  int i;
  for (i = 0; i < ARRAY_MAX; i++) {
    if ((x->front < x->end) && (x->front <= i) && (i < x->end)) {
      /* 終端に到達していない時 */
      printf("%3.3d : %3.3d : %d\n", i, i - x->front, x->array[i]); 
    } else if ((x->front > x->end) && (x->front >= i) && (x->end < i)) {
      /* 終端を超えた時 */
      printf("%3.3d : %3.3d : %d\n", i, i - x->end, x->array[i]);
    } else {
      /* No data */
      printf("%3.3d : ***\n", i);
    }
  }
}
---

3.1.2. 実行結果 // コンソールをコピー
[a243392@xdev02 kadai3]$ gcc prog_3_1.c
[a243392@xdev02 kadai3]$ ./prog31
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 1
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 2
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 3
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 4
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
-- No resource remained. --
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 2
Dequeue: 1
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 2
Dequeue: 2
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 5
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 1
Input a number to enqueue: 6
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 3
3 4 5 6 
Enter the operation number.
1. Enqueue, 2. Dequeue, 3. Print, 4. Exit: 4
[a243392@xdev06 prog]$


3.2．スタック
3.2.1. プログラム
--- prog_3_2.c 
/* header files */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
/* define */
#define MAX 10
/* structure */
typedef struct stack {
  double array[MAX];
  int counter;
} Stack;
/* functions */
void read_rpn(void);
void push(Stack *x, double n);
double pop(Stack *x);

/* main */
int main(void) {
  read_rpn();
  return 0;
}

/* four basic arithmetic operations on positive real numbers */
void read_rpn(void) {
  Stack x;
  int ch;
  double num1, num2;
  x.counter = 0;
  printf("Enter an equation in Reverse Polish Notation: "); //the input should be 10 2 4 * - 3 + 4 2 - /
  while((ch = getchar()) != EOF) {
    if (isdigit(ch)) { // the token is a digit
      // convert a character code to a number
      ungetc(ch, stdin);
      scanf("%lf", &num1);
      push(&x, num1);
    } else { // the token is not a digit
      switch(ch) {
      case '+':
        num2 = pop(&x); num1 = pop(&x);
        push(&x, num1 + num2);
        break;
      case '-':
        num2 = pop(&x); num1 = pop(&x);
        push(&x, num1 - num2);
        break;
      case '*':
        num2 = pop(&x); num1 = pop(&x);
        push(&x, num1 * num2);
        break;
      case '/':
        num2 = pop(&x); num1 = pop(&x);
        push(&x, num1 / num2);
        break;
      case ' ': break;
      case '\n':
        if (x.counter <= 1) {
          printf("Answer: %.15f\n", pop(&x));
          exit(0);
        } else {
          puts("Stack is not empty.");
          exit(1);
        }
      default:
        puts("Wrong characters entered.");
        exit(1);
      }
    }
  }
}

void push(Stack *x, double n)
{
  if(x->counter < MAX){
    x->array[x->counter] = n;
    x->counter++;
  }
  else {
    printf("Stack Overflow!");
    exit(0);
  }
}

double pop(Stack *x)
{
  if(x->counter > 0){
    x->counter--;
    return x->array[x->counter];
  }
  else {
    printf("Stack Underflow!");
    exit(1);
  }
}
---

3.2.2. 実行結果
[a243392@xdev02 kadai3]$ gcc prog_3_2.c
[a243392@xdev02 kadai3]$ ./prog32
Enter an equation in Reverse Polish Notation: 10 2 4 * - 3 + 4 2 - /
Answer: 2.500000000000000
[a243392@xdev02 kadai3]$ ./prog32
Enter an equation in Reverse Polish Notation: 1 2 / - 2 3 + * 3 1 / *
Stack Overflow!
[a243392@xdev02 kadai3]$ ./prog32
Enter an equation in Reverse Polish Notation: 10 4 2 -
Stack is not empty.
[a243392@xdev02 kadai3]$ ./prog32
Enter an equation in Reverse Polish Notation: - 10 2
Stack Underflow!
[a243392@xdev02 kadai3]$ 


1.4. 感想 // 150字程度
キューとスタックは何回も勉強したことがあるので、基本の動きは分かったが、C言語で書くのが初めてなので、最初の30分ぐらいはプログラムを理解するために時間をかかった。
プログラムを理解し、課題をする時間が合計40分だった。なぜなら、小さなミスをしたからだ。それ以外は順調である。