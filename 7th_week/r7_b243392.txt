プログラミング応用演習I 第7回課題レポート 
氏名: Alcander Imawan
学籍番号: b243392
提出年月日: 2024年6月14日

7.1．binary関数
7.1.1. プログラム
--- prog_7_1.c
/* header files */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

/* define */
#define N 30     // the number of array elements
#define MAX 100  // the range of elements (1 - MAX)

/* functions */
int binary(int array[], int target);
void quick_sort(int array[], int front, int rear);

/* main */
int main(void) {
  int target, array[N], i;
  srand((unsigned int )time(NULL)); // set seed for randomization
  for (i = 0; i < N; i++) {
    array[i] = rand() % MAX + 1;
  }
  quick_sort(array, 0, N - 1);

  puts("An array of integers in ascending order.");
  for (i = 0; i < N; i++) {
    printf("%d ", array[i]);
  }
  printf("\nBinary search for the target: ");
  scanf("%d", &target);

  if (binary(array, target) == 1) {
    printf("The target %d was found.\n", target);
  } else {
    printf("The target %d was Not found.\n", target);
  }
  return 0;
}

/* binary search */
int binary(int array[], int target) {
  int front = 0, rear = N - 1;

  /* write search program here */
    while (front <= rear) {
        int mid = (front + rear) / 2;
        if (array[mid] == target) {
            return 1; // Target found
        } else if (array[mid] < target) {
            front = mid + 1; // Search the right half
        } else {
            rear = mid - 1; // Search the left half
        }
    }

  return 0;
}

/* example_5_2.c*/
#define SWAP(type_, xx, yy) { type_ temp = xx; xx = yy; yy = temp; }
/* sorting by quick sort */
void quick_sort(int array[], int front, int rear) {
  // for 2 elements
  if (rear - front == 1) {
    if (array[front] > array[rear]) {
      int diff = array[front];
      array[front] = array[rear];
      array[rear] = diff;
    }
    return;
  }
  int pivot, pindex, f, r;
  f = front; r = rear;
  pindex = (f + r)/2;
  pivot = array[ pindex ]; /* pivot selection */
  do {
    while (f <= rear  && array[f] <  pivot) {  f++; }
    while (r >= front && array[r] >= pivot) {  r--; }
    if (f <= r) {
      SWAP(int, array[f], array[r]);
      f++;
      r--;
    }
  } while (f <= r);
  if (r < front) { // there is no element less than pivot
    SWAP(int, array[front], array[pindex]);
    quick_sort(array, front+1, rear);
  } else {
    if (front < r) {
      quick_sort(array, front, r);
    }
    if (f < rear)  {
      quick_sort(array, f, rear);
    }
  }
}
---

7.1.2. 実行結果 // コンソールをコピー
[a243392@xdev05 kadai7]$ gcc prog_7_1.c
[a243392@xdev05 kadai7]$ ./prog71
An array of integers in ascending order.
1 1 2 8 9 10 12 15 17 17 24 24 25 27 45 54 59 61 61 64 66 67 71 77 83 86 91 92 92 94
Binary search for the target: 12
The target 12 was found.
[a243392@xdev05 kadai7]$

7.2．二分法を用いた解の探索
7.2.1. プログラム
--- prog_7_2.c 
/* 〇課題7.2 */
/* header files */
#include <stdio.h>
#include <stdlib.h>

/* functions */
double bisection(double front, double rear);
double f(double x);

/* main */
int main(void) {
  double front, rear;
  puts("An approximate solution to (x - 6)^3 + 8 = 0.");
  printf("Enter front and rear values with a space between them (front < rear): ");
  scanf("%lf%lf", &front, &rear);

  printf("x = %f\n", bisection(front, rear));

  return 0;
}

/* bisection method */
double bisection(double front, double rear) {
  double mid, eps = 0.001;

  if (f(front) * f(rear) > 0) {
    puts("Invalid values were entered.");
    exit(1);
  }

  /* write search program here */
  while ((rear - front) > eps) {
    mid = (front + rear) / 2;
    if (f(mid) == 0.0) {
      return mid; 
    } else if (f(front) * f(mid) < 0) {
      rear = mid;
    } else {
      front = mid;
    }
  }

  return front;
}

/* function to calculate (x - 6)^3 + 8 */
double f(double x) {
  return (x - 6) * (x - 6) * (x - 6) + 8;
}
---

7.2.2. 実行結果
[a243392@xdev05 kadai7]$ gcc prog_7_2.c
[a243392@xdev05 kadai7]$ ./prog72
An approximate solution to (x - 6)^3 + 8 = 0.
Enter front and rear values with a space between them (front < rear): 1 6
x = 3.999878
[a243392@xdev05 kadai7]$ ./prog72
An approximate solution to (x - 6)^3 + 8 = 0.
Enter front and rear values with a space between them (front < rear): 0 3
Invalid values were entered.
[a243392@xdev05 kadai7]$ 

7.3．二分法の反復回数
7.3.1．プログラム
--- prog_7_3.c
/* header files */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* functions */
double bisection(double front, double rear, double epsilon);
double f(double x);

/* main */
int main(void) {
  double front, rear, epsilon;
  int predicted_iterations;
  puts("An approximate solution to (x - 6)^3 + 8 = 0.");
  printf("Enter front and rear values with a space between them (front < rear): ");
  scanf("%lf%lf", &front, &rear);

  epsilon = 0.001;
  printf("The convergence epsilon is %6f\n", epsilon);

  predicted_iterations = (int)(log((rear - front) / epsilon) / log(2)) + 1;
  printf("The predicted iteration number is %d\n", predicted_iterations);
  printf("x = %f\n", bisection(front, rear, epsilon));

  return 0;
}

/* bisection method */
double bisection(double front, double rear, double epsilon) {
  double mid;
  int count;

  if (f(front) * f(rear) > 0) {
    puts("Invalid values were entered.");
    exit(1);
  }

  
  /* write search program here */
  count = 0;
  while ((rear - front) > epsilon) {
    mid = (front + rear) / 2;
    printf("%d f = %6f, r = %6f\n", count + 1, front, rear);
    if (f(mid) == 0.0) {
      return mid; 
    } else if (f(front) * f(mid) < 0) {
      rear = mid;
    } else {
      front = mid;
    }
    count += 1;
  }

  return front;
}

/* function to calculate (x - 6)^3 + 8 */
double f(double x) {
  return (x - 6) * (x - 6) * (x - 6) + 8;
}
---

7.3.2．実行結果
[a243392@xdev05 kadai7]$ gcc prog_7_3.c
[a243392@xdev05 kadai7]$ ./prog73
An approximate solution to (x - 6)^3 + 8 = 0.
Enter front and rear values with a space between them (front < rear): 1 6
The convergence epsilon is 0.001000
The predicted iteration number is 13
1 f = 1.000000, r = 6.000000
2 f = 3.500000, r = 6.000000
3 f = 3.500000, r = 4.750000
4 f = 3.500000, r = 4.125000
5 f = 3.812500, r = 4.125000
6 f = 3.968750, r = 4.125000
7 f = 3.968750, r = 4.046875
8 f = 3.968750, r = 4.007813
9 f = 3.988281, r = 4.007813
10 f = 3.998047, r = 4.007813
11 f = 3.998047, r = 4.002930
12 f = 3.998047, r = 4.000488
13 f = 3.999268, r = 4.000488
x = 3.999878
[a243392@xdev05 kadai7]$

7.4. 感想 // 150字程度
分割統治アルゴリズムはアルゴリズムとデータ構造で習いましたので、結構楽でした。
課題7.2の時、double f(double x)の関数を忘れてしまって、30分ぐらいかかりました。
課題7.3で実際にループ回数を計算がわからなかったので、ネットで調べました。


